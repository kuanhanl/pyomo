#  ___________________________________________________________________________
#
#  Pyomo: Python Optimization Modeling Objects
#  Copyright (c) 2008-2022
#  National Technology and Engineering Solutions of Sandia, LLC
#  Under the terms of Contract DE-NA0003525 with National Technology and
#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
#  rights in this software.
#  This software is distributed under the 3-clause BSD License.
#  ___________________________________________________________________________
#################################################################################
# The Institute for the Design of Advanced Energy Systems Integrated Platform
# Framework (IDAES IP) was produced under the DOE Institute for the
# Design of Advanced Energy Systems (IDAES), and is copyright (c) 2018-2021
# by the software owners: The Regents of the University of California, through
# Lawrence Berkeley National Laboratory,  National Technology & Engineering
# Solutions of Sandia, LLC, Carnegie Mellon University, West Virginia University
# Research Corporation, et al.  All rights reserved.
#
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and
# license information.
#################################################################################

import enum

class NoiseBoundOption(enum.Enum):
    FAIL = 60
    DISCARD = 61
    PUSH = 62


def get_violated_bounds(val, bounds):
    """This function tests a value against a lower and an upper bound,
    returning which if either is violated, as well as a direction
    that the value needs to move for feasibility.
    Arguments:
        val: Value to be tested
        bounds: Tuple containing the lower, upper bounds
    """
    lower = bounds[0]
    upper = bounds[1]
    if upper is not None:
        if val > upper:
            return (upper, -1)
    if lower is not None:
        if val < lower:
            return (lower, 1)
    return (None, 0)


class MaxDiscardError(Exception):
    pass


def apply_noise(val_list, noise_params, noise_function):
    """
    Applies noise to each value in a list of values and returns the result.
    Noise is generated by a user-provided function that maps a value and
    parameters to a random value.
    """
    result = []
    for val, params in zip(val_list, noise_params):
        if type(params) is not tuple:
            # better be a scalar
            params = (params,)
        result.append(noise_function(val, *params))
    return result


def apply_bounded_noise_discard(
    val, params, noise_function, bounds, max_number_discards
):
    i = 0
    while i <= max_number_discards:
        newval = noise_function(val, *params)

        violated_bound, direction = get_violated_bounds(newval, bounds)
        if violated_bound is None:
            return newval
        else:
            # Discard.
            i += 1

    # This could be caught by the caller to raise a more useful
    # error that includes the variable whose noise violates a
    # bound.
    raise MaxDiscardError("Max number of discards exceeded when applying noise.")


def apply_bounded_noise_push(val, params, noise_function, bounds, bound_push):
    newval = noise_function(val, *params)
    violated_bound, direction = get_violated_bounds(newval, bounds)
    if not violated_bound:
        return newval
    return violated_bound + bound_push * direction


def apply_bounded_noise_fail(val, params, noise_function, bounds):
    newval = noise_function(val, *params)
    violated_bound, direction = get_violated_bounds(newval, bounds)
    if violated_bound:
        raise RuntimeError("Applying noise caused a bound to be violated")
    return newval


def apply_noise_with_bounds(
    val_list,
    noise_params,
    noise_function,
    bound_list,
    bound_option=NoiseBoundOption.DISCARD,
    max_number_discards=5,
    bound_push=0.0,
):
    result = []
    for val, params, bounds in zip(val_list, noise_params, bound_list):
        if type(params) is not tuple:
            # better be a scalar
            # better check: if type(params) not in {sequence_types}...
            params = (params,)

        if bound_option == NoiseBoundOption.DISCARD:
            newval = apply_bounded_noise_discard(
                val, params, noise_function, bounds, max_number_discards
            )
        elif bound_option == NoiseBoundOption.PUSH:
            newval = apply_bounded_noise_push(
                val, params, noise_function, bounds, bound_push
            )
        elif bound_option == NoiseBoundOption.FAIL:
            newval = apply_bounded_noise_fail(val, params, noise_function, bounds)
        else:
            raise RuntimeError("Bound violation option not recognized")

        result.append(newval)
    return result
